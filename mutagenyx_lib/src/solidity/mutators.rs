//! The `solidity::mutators` module provides the objects that implement the mutation algorithms
//! for the Solidity ASTs.  The module also provides the factory that implements [`MutatorFactory<T>`].

use crate::error::MutagenyxError;
use crate::json::{new_json_node, JSONMutate};
use crate::mutation::{GenericMutation, MutationType, SolidityMutation};
use crate::mutator::{Mutator, MutatorFactory};
use crate::mutator_result::MutatorResult;
use crate::node_printer_helpers::traverse_sub_node_and_print;
use crate::operators::*;
use crate::solidity::ast::{SolidityAST, SolidityASTApi};
use crate::solidity::pretty_printer::SolidityNodePrinterFactory;
use crate::PrettyPrinter;
use hex;
use num::Integer;
use openssl::hash::{Hasher, MessageDigest};
use rand::seq::SliceRandom;
use rand::{Rng, RngCore};
use rand_pcg::*;
use serde_json::json;
use std::collections::HashMap;
use std::fmt;

/// Return a new integer literal node representing an integer literal number.
///
/// # Argument
/// * `value` - The number that the node should contain.
fn new_integer_constant_node<I: Integer + fmt::Display>(
    value: I,
) -> Result<SolidityAST, MutagenyxError> {
    let value_str = value.to_string();
    let hex_value_str = hex::encode(value_str.as_bytes());
    let node_string = format!(
        "{{
        \"hexValue\": \"{hex_value_str}\",
        \"id\": 9999997,
        \"isConstant\": false,
        \"isLValue\": false,
        \"isPure\": true,
        \"kind\": \"number\",
        \"lValueRequested\": false,
        \"nodeType\": \"Literal\",
        \"typeDescriptions\": {{
            \"typeIdentifier\": \"t_rational_{value}_by_1\",
            \"typeString\": \"int_const {value}\"
        }},
        \"value\": \"{value}\"
        }}
    "
    );
    new_json_node(&node_string)
}

/// Return a new boolean literal node.
///
/// # Argument
///
/// * `value` - The boolean value to store in the node.
fn new_boolean_literal_node(value: bool) -> Result<SolidityAST, MutagenyxError> {
    let value_str = value.to_string();
    let hex_value_str = hex::encode(value_str.as_bytes());
    let node_string = format!(
        "{{\
        \"hexValue\": \"{hex_value_str}\",
        \"id\": 9999998,
        \"isConstant\": false,
        \"isLValue\": false,
        \"isPure\": true,
        \"kind\": \"bool\",
        \"lValueRequested\": false,
        \"nodeType\": \"Literal\",
        \"typeDescriptions\": {{
            \"typeIdentifier\": \"t_bool\",
            \"typeString\": \"bool\"
        }},
        \"value\": \"{value}\"
    }}"
    );
    new_json_node(&node_string)
}

/// Return a new comment node.
///
/// **Important**: Comment nodes do not naturally occur in Solidity AST files (not yet) and so
/// any AST with a comment node no longer conforms to the standard AST format generated by the
/// Solidity compiler.
///
/// # Arguments
///
/// * `text` - The reference to the string content that contains the text to add to the comment.
fn new_comment_node(text: &str) -> Result<SolidityAST, MutagenyxError> {
    let text_node = json![text];

    let node_string = "{\
            \"id\": 9999997,
            \"isConstant\": false,
            \"isLValue\": false,
            \"isPure\": false,
            \"lValueRequested\": false,
            \"nodeType\": \"Comment\",
            \"text\": null
        }";

    let mut node = new_json_node(node_string)?;
    node.set_node_for_key("text", text_node);
    Ok(node)
}

/// Return a new comment node populated with the value of `node`.
///
/// # Arguments
///
/// * `node` - A [`SolidityAST`] node to embed in the comment.
fn new_comment_node_from_node(node: SolidityAST) -> Result<SolidityAST, MutagenyxError> {
    let node_string = "{\
            \"id\": 9999997,
            \"isConstant\": false,
            \"isLValue\": false,
            \"isPure\": false,
            \"lValueRequested\": false,
            \"nodeType\": \"Comment\",
            \"value\": null
        }";

    let id_value: i64 = node.get_int_for_key("id").unwrap_or(9999997);

    let mut new_node = new_json_node(node_string)?;
    new_node.set_node_for_key("value", node);

    // The commenting algorithms need to be able to find the id of the original node.
    // Since the original node is effectively going away, we move the id from the node
    // into the comment node.
    new_node.set_node_for_key("id", json![id_value]);

    Ok(new_node)
}

/// Helper function to generate a new unary operator node.
///
/// # Arguments
///
/// * `operator` - The text of the operator (!, --, ++, ~, etc...).
/// * `prefix` - True if the unary operator is a prefix operator and false for postfix.
/// * `sub_expression` - The node to which the operator applies.
fn new_unary_op_node(
    operator: &str,
    prefix: bool,
    sub_expression: SolidityAST,
) -> Result<SolidityAST, MutagenyxError> {
    let node_string = format!(
        "{{\
            \"id\": 9999996,
            \"isConstant\": false,
            \"isLValue\": false,
            \"isPure\": false,
            \"lValueRequested\": false,
            \"nodeType\": \"UnaryOperation\",
            \"operator\": \"{operator}\",
            \"prefix\": {prefix},
            \"subExpression\": null
        }}"
    );

    let mut node = new_json_node(&node_string)?;
    node.set_node_for_key("subExpression", sub_expression);
    Ok(node)
}

/// Helper function for generating a new TupleExpression.
///
/// # Arguments
///
/// * `array` - An array of SolidityAST nodes to place in the TupleExpression components array.
fn new_tuple_expression_node(array: Vec<SolidityAST>) -> Result<SolidityAST, MutagenyxError> {
    let node_array = json![array];

    let node_str = "{\
            \"id\": 9999995,
            \"isConstant\": false,
            \"IsInlineArray\": false,
            \"isLValue\": false,
            \"isPure\": false,
            \"lValueRequested\": false,
            \"nodeType\": \"TupleExpression\",
            \"components\": null
        }";

    let mut tuple_node = new_json_node(node_str)?;
    tuple_node.set_node_for_key("components", node_array);
    Ok(tuple_node)
}

/// Helper function to wrap an array of nodes in a Solidity UncheckedBlock node.
///
/// # Arguments
///
/// * `array` - The vector of [`SolidityAST`] nodes to place in the UncheckedBlock
fn new_unchecked_block_node(
    array: Vec<SolidityAST>,
    node_id: u64,
) -> Result<SolidityAST, MutagenyxError> {
    let node_array = json![array];

    let node_str = "{\
            \"id\": 9999994,
            \"nodeType\": \"UncheckedBlock\",
            \"statements\": null
        }";

    let mut unchecked_node = new_json_node(node_str)?;
    unchecked_node.set_node_for_key("statements", node_array);
    unchecked_node.set_node_for_key("id", json![node_id]);
    Ok(unchecked_node)
}

/// Return the string containing the pretty-printed form of `node`.
///
/// # Arguments
///
/// * `node` - The node to pretty-print.
fn pretty_print_node(node: &SolidityAST) -> String {
    let mut node_contents = Vec::new();
    let mut printer = PrettyPrinter::new(4, 150);
    let factory = SolidityNodePrinterFactory::default();
    traverse_sub_node_and_print(&mut printer, &mut node_contents, &factory, node);

    // s now contains the pretty-printed node.
    let s = core::str::from_utf8(node_contents.as_slice()).unwrap();
    String::from(s)
}

/// The object that implements mutations for binary expressions.
///
/// Multiple mutation algorithms operate on binary expressions.  Each of those
/// mutation algorithms uses a subset of the available binary operators.  This
/// one structure/class provides the functionality to implement these different
/// binary expression mutations.
struct BinaryOpMutator {
    /// A list of operators valid for the binary expression
    operators: Vec<&'static str>, //Vec<String>,

    /// The mutation algorithm implemented by the mutator.
    mutation_type: MutationType,

    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl BinaryOpMutator {
    /// Return a new instance of the mutator.
    ///
    /// # Arguments
    ///
    /// * `operators` - the list of operators for the mutator
    /// * `mutation_type` - the mutation algorithm implemented by the mutator
    pub fn new(
        operators: Vec<&'static str>, /* Vec<String> */
        mutation_type: MutationType,
    ) -> BinaryOpMutator {
        BinaryOpMutator {
            operators,
            mutation_type,
            comment_node: None,
        }
    }
}

impl Mutator<SolidityAST> for BinaryOpMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        // First check to see if the node in the AST is a "BinaryOperation" node.
        if let Some(n) = node.get_str_for_key("nodeType") {
            if n == "BinaryOperation" {
                // Get the operator from the node and see if the operator is in the mutator's
                // list of supported operators. The mutator can mutate the node if it supports
                // the node's operator.
                if let Some(op) = node.get_str_for_key("operator") {
                    return self.operators.contains(&op);
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Remove any previous comment.
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        if let Some(original_operator) = node.get_str_for_key("operator") {
            // Get the original operator so that we can use it to compare for the
            // randomly chosen new operator. We do not want to replace the original operator
            // with itself, just by randomly selecting the same operator from the operator list.
            let mut chosen_operator = match self.operators.choose(rand) {
                Some(o) => o,
                None => {
                    return Err(MutagenyxError::RandomOperationFailure(
                        "invalid operator choice",
                    ))
                }
            };

            let original_operator_s = String::from(original_operator);

            // If we chose the original operator, keep choosing until we get a different operator.
            while original_operator == *chosen_operator {
                chosen_operator = match self.operators.choose(rand) {
                    Some(o) => o,
                    None => {
                        return Err(MutagenyxError::RandomOperationFailure(
                            "invalid operator choice",
                        ))
                    }
                };
            }

            hasher.update(chosen_operator.as_bytes())?;
            let byte_array = hasher.finish()?;
            mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

            // Insert the new operator into the node.
            node.set_str_for_key("operator", chosen_operator);

            let comment_text = format!(
                "{} Mutator: changed '{}' to '{}'",
                self.mutation_type, original_operator_s, chosen_operator
            );
            if let Ok(comment_node) = new_comment_node(&comment_text) {
                self.comment_node = Some(comment_node);
            }

            if let Some(id) = node.get_int_for_key("id") {
                mutation_result.mutated_node_id = Some(id as u64);
            }
        }
        Ok(mutation_result)
    }

    fn implements(&self) -> MutationType {
        self.mutation_type
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// The structure/class that implements mutations for unary expressions.
struct UnaryOpMutator {
    /// A list of operators usable as prefix operators.
    prefix_operators: Vec<&'static str>,

    /// A list of operators usable as postfix operators.
    postfix_operators: Vec<&'static str>,

    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl UnaryOpMutator {
    /// Create a new unary expression mutator.
    pub fn new() -> UnaryOpMutator {
        UnaryOpMutator {
            prefix_operators: prefix_operators(),
            postfix_operators: postfix_operators(),
            comment_node: None,
        }
    }
}

impl Mutator<SolidityAST> for UnaryOpMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        // First check to see if the node is a 'UnaryOperation' node.
        if let Some(n) = node.get_str_for_key("nodeType") {
            if n == "UnaryOperation" {
                // Now check the 'prefix' member of the node and if the node is a prefix operation
                // use the prefix operator list and otherwise use the postfix operator list.
                let operator_list = match node.get_bool_for_key("prefix") {
                    Some(p) => {
                        if p {
                            &self.prefix_operators
                        } else {
                            &self.postfix_operators
                        }
                    }
                    _ => {
                        log::info!(
                            "Found a UnaryOperator node with no prefix information: {:?}",
                            node
                        );
                        return false;
                    }
                };

                // Check to see if the operator in the node is in the operator list for the
                // mutator
                if let Some(op) = node.get_str_for_key("operator") {
                    return operator_list.contains(&op);
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Remove previously existing comment.
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        // Determine if the node is a prefix/postfix operation and then use the prefix or
        // postfix operator list.
        let operator_list = match node.get_bool_for_key("prefix") {
            Some(p) => {
                if p {
                    hasher.update(&[0])?;
                    &self.prefix_operators
                } else {
                    hasher.update(&[1])?;
                    &self.postfix_operators
                }
            }
            _ => {
                log::info!(
                    "Mutate found a UnaryOperator node with no prefix information: {:?}",
                    node
                );
                return Err(MutagenyxError::MalformedNode(
                    String::from("UnaryOperator"),
                    String::from("prefix"),
                ));
            }
        };

        // Get the original operator that we can use to compare to the new operator that we select.
        // If the operator choice selects the same operator as the original, then we want to keep
        // selecting operators until we have a different operator.
        let original_operator = node.get_str_for_key("operator").unwrap_or("");

        // Make copy of the operator for use with comments later.
        let original_operator_s = String::from(original_operator);

        let bad_choice_err = Err(MutagenyxError::RandomOperationFailure(
            "Did not select a good replacement operator",
        ));

        // Choose a new operator.
        let mut chosen_operator = match operator_list.choose(rand) {
            Some(o) => o,
            None => return bad_choice_err,
        };

        // If the operators match, choose another operator until they no longer match.
        while original_operator == *chosen_operator {
            chosen_operator = match operator_list.choose(rand) {
                Some(o) => o,
                None => return bad_choice_err,
            };
        }

        hasher.update(chosen_operator.as_bytes())?;
        let byte_array = hasher.finish()?;
        mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

        node.set_str_for_key("operator", chosen_operator);

        let comment_text = format!(
            "UnaryOp Mutator: Changed '{}' to '{}'",
            original_operator_s, chosen_operator
        );
        if let Ok(comment_node) = new_comment_node(&comment_text) {
            self.comment_node = Some(comment_node);
        }

        mutation_result.mutated_node_id = node.get_int_for_key("id").map(|id| id as u64);
        Ok(mutation_result)
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::UnaryOp)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Implements the assignment mutation algorithm.
///
/// For a given Assigment expression, the algorithm replaces the right-hand side of the expression
/// with a type correct random value.  Specifically the algorithm operates on assignments to
/// integer, unsigned integer, and boolean variables.  For signed and unsigned integers, the
/// algorithm will recognize the range of the type and generate random numbers that lie in the
/// range.  Since rust only supports a maximum of 128-bit signed and unsigned integers, Solidity
/// types larger than that will only receive a random number in the 128-bit range.
struct AssignmentMutator {
    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl AssignmentMutator {
    /// Create the new mutator.
    pub fn new() -> AssignmentMutator {
        AssignmentMutator { comment_node: None }
    }
}

impl Mutator<SolidityAST> for AssignmentMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        // First check to see if the node is an `Assignment` node.
        if let Some(n) = node.get_str_for_key("nodeType") {
            if n == "Assignment" {
                // Now recover the type information from the node.
                let type_description_node = match node.get("typeDescriptions") {
                    Some(n) => n,
                    _ => {
                        log::info!("Assignment node has no type description object");
                        return false;
                    }
                };

                let type_string = match type_description_node.get_str_for_key("typeString") {
                    Some(s) => s,
                    _ => {
                        log::info!("Assignment node's type description has no type string");
                        return false;
                    }
                };

                if type_string.len() < 3 {
                    return false;
                }

                let first_three_chars = &type_string[..3];

                return matches!(first_three_chars, "uin" | "int" | "boo");
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Remove previously existing comment
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        // Recover the type descriptions for the node.
        let type_description_node = match node.get("typeDescriptions") {
            Some(n) => n,
            _ => {
                log::info!("Assignment node has no type description object");
                return Err(MutagenyxError::MalformedNode(
                    String::from("Assignment"),
                    String::from("typeDescriptions"),
                ));
            }
        };

        let type_string = match type_description_node.get_str_for_key("typeString") {
            Some(s) => s,
            _ => {
                log::info!("Assignment node's type description has no type string");
                return Err(MutagenyxError::MalformedNode(
                    String::from("Assignment"),
                    String::from("typeString"),
                ));
            }
        };

        let original_rhs_s = if let Some(rhs_node) = node.get("rightHandSide") {
            pretty_print_node(rhs_node)
        } else {
            log::info!("Did not find right hand side in Assignment mutator");
            return Err(MutagenyxError::MalformedNode(
                String::from("Assignment"),
                String::from("rightHandSide"),
            ));
        };

        let first_three_chars = &type_string[..3];

        match first_three_chars {
            "int" => {
                hasher.update("int".as_bytes())?;

                let type_size_str = &type_string[3..];
                let mut type_size = type_size_str.parse::<u32>().unwrap();

                if type_size > 128 {
                    type_size = 128;
                }

                let lower_bound = -(2_i128.pow(type_size - 1));
                let upper_bound = 2_i128.pow(type_size - 1);
                let replacement_value = rand.gen_range(lower_bound, upper_bound);

                hasher.update(&replacement_value.to_ne_bytes())?;

                let new_node = match new_integer_constant_node(replacement_value) {
                    Ok(n) => n,
                    _ => return Err(MutagenyxError::UnableToGenerateNode("integer constant")),
                };

                node.set_node_for_key("rightHandSide", new_node);
            }
            "uin" => {
                hasher.update("uin".as_bytes())?;

                let type_size_str = &type_string[4..];
                let mut type_size = type_size_str.parse::<u32>().unwrap();

                if type_size > 128 {
                    type_size = 128;
                }

                let lower_bound = 0_u128;
                let upper_bound: u128 = if type_size < 128 {
                    2_u128.pow(type_size) - 1
                } else {
                    // 2.pow(128) - 1
                    340282366920938463463374607431768211455u128
                };

                let replacement_value = rand.gen_range(lower_bound, upper_bound);

                hasher.update(&replacement_value.to_ne_bytes())?;

                let new_node = match new_integer_constant_node(replacement_value) {
                    Ok(n) => n,
                    _ => return Err(MutagenyxError::UnableToGenerateNode("integer constant")),
                };

                node.set_node_for_key("rightHandSide", new_node);
            }
            "boo" => {
                hasher.update("boo".as_bytes())?;

                assert_eq!(type_string, "bool");
                let replacement_value: i8 = rand.gen_range(0, 1);
                let bool_literal: bool = replacement_value != 0;

                hasher.update(&replacement_value.to_ne_bytes())?;

                let new_node = match new_boolean_literal_node(bool_literal) {
                    Ok(n) => n,
                    _ => return Err(MutagenyxError::UnableToGenerateNode("boolean literal")),
                };

                node.set_node_for_key("rightHandSide", new_node);
            }
            _ => (),
        }

        let new_rhs_s = if let Some(rhs_node) = node.get("rightHandSide") {
            pretty_print_node(rhs_node)
        } else {
            log::info!("Could not get right hand side after Assignment mutation");
            return Err(MutagenyxError::MalformedNode(
                String::from("Assignment"),
                String::from("rightHandSize"),
            ));
        };

        let comment_text = format!(
            "Assignment Mutator: Replaced '{}' with '{}'",
            original_rhs_s, new_rhs_s
        );
        if let Ok(comment_node) = new_comment_node(&comment_text) {
            self.comment_node = Some(comment_node);
        }

        mutation_result.mutated_node_id = node.get_int_for_key("id").map(|id| id as u64);

        let byte_array = hasher.finish()?;
        mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

        Ok(mutation_result)
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::Assignment)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Type that implements the DeleteStatement algorithm.
///
/// The algorithm chooses a random ExpressionStatement node in any Block and replaces that statement
/// with a comment node.
struct DeleteStatementMutator {
    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl DeleteStatementMutator {
    /// Create the new delete statement mutator.
    pub fn new() -> DeleteStatementMutator {
        DeleteStatementMutator { comment_node: None }
    }
}

impl Mutator<SolidityAST> for DeleteStatementMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        // We are looking for a Block node that has at least one ExpressionStatement
        // in the body of the function.
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "Block" {
                if let Some(statements_node) = node.get("statements") {
                    if let Some(statements_array) = statements_node.as_array() {
                        if statements_array.len() > 1 {
                            // The array needs to have at least one ExpressionStatement.
                            for value in statements_array {
                                if let Some(value_type) = value.get_str_for_key("nodeType") {
                                    if value_type == "ExpressionStatement" {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Remove previously existing comment.
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        // We have a Block node that has a statements array with at least one
        // ExpressionStatement. Go through the statements and pick one randomly in order
        // to delete the statement.

        if let Some(mut statements_node) = node.take_value_for_key("statements") {
            if let Some(statements_array) = statements_node.as_array_mut() {
                let mut expression_statement_indexes: Vec<usize> = vec![];
                for (index, value) in statements_array.iter().enumerate() {
                    if value.is_object() {
                        if let Some(value_type) = value.get_str_for_key("nodeType") {
                            if value_type == "ExpressionStatement" {
                                expression_statement_indexes.push(index);
                            }
                        }
                    }
                }

                // Now pick a random index.
                let vector_index =
                    (rand.next_u64() % expression_statement_indexes.len() as u64) as usize;

                hasher.update(&vector_index.to_ne_bytes())?;

                let value = statements_array.remove(expression_statement_indexes[vector_index]);

                let value_s = pretty_print_node(&value);

                mutation_result.mutated_node_id = value.get_int_for_key("id").map(|id| id as u64);

                let new_node = match new_comment_node_from_node(value) {
                    Ok(node) => node,
                    Err(_e) => return Err(MutagenyxError::UnableToGenerateNode("comment node")),
                };

                statements_array.insert(expression_statement_indexes[vector_index], new_node);

                node.set_node_for_key("statements", statements_node);

                let comment_text =
                    format!("DeleteStatement Mutator: deleted statement '{}'", value_s);
                if let Ok(comment_node) = new_comment_node(&comment_text) {
                    self.comment_node = Some(comment_node);
                }

                let byte_array = hasher.finish()?;
                mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

                return Ok(mutation_result);
            }
        }

        Err(MutagenyxError::MalformedNode(
            String::from("Block"),
            String::from("statements"),
        ))
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::DeleteStatement)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Helper struct for FunctionCall mutation algorithm.
///
/// The mutation algorithm keeps track of argument indexes and values with IndexedNode
/// objects.
struct IndexedNode {
    /// The index of the node in the function call arguments array.
    pub index: usize,

    /// A copy of the argument found at `index`.
    pub node: SolidityAST,
}

impl IndexedNode {
    /// Create a new IndexedNode object.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the node from the arguments array.
    /// * `node` - A copy of the node from the arguments array.
    fn new(index: usize, node: SolidityAST) -> IndexedNode {
        IndexedNode { index, node }
    }
}

/// Implements the FunctionCall mutation algorithm.
///
/// The algorithm selects a random function call and replaces the function call with one of the
/// arguments from the function call.  The algorithm does not check the return type of the function
/// from the function's definition to select an argument that matches the return type.
struct FunctionCallMutator {
    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl FunctionCallMutator {
    /// Create a new function-call mutator.
    pub fn new() -> FunctionCallMutator {
        FunctionCallMutator { comment_node: None }
    }
}

impl Mutator<SolidityAST> for FunctionCallMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        // We only want function call nodes with at least 1 argument.
        // We may want to ignore require() functions.
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "FunctionCall" {
                if let Some(arguments_node) = node.get("arguments") {
                    if let Some(arguments_array) = arguments_node.as_array() {
                        if !arguments_array.is_empty() {
                            let mut has_literal = false;
                            for value in arguments_array {
                                if let Some(value_node_type) = value.get_str_for_key("nodeType") {
                                    if value_node_type == "Literal" {
                                        has_literal = true;
                                        break;
                                    }
                                }
                            }

                            if has_literal && arguments_array.len() > 1 {
                                return true;
                            } else if has_literal {
                                return false;
                            }

                            return true;
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Remove previously existing comment
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        if let Some(arguments_node) = node.get("arguments") {
            if let Some(arguments_array) = arguments_node.as_array() {
                let original_node_s = pretty_print_node(node);
                loop {
                    // Randomly pick an array member, but avoid Literal nodes.
                    let index = (rand.next_u64() % arguments_array.len() as u64) as usize;
                    let value = &arguments_array[index];
                    if let Some(node_type) = value.get_str_for_key("nodeType") {
                        if node_type == "Literal" {
                            continue;
                        }
                    }

                    hasher.update(&index.to_ne_bytes())?;

                    *node = value.clone();
                    break;
                }
                let new_node_s = pretty_print_node(node);
                let comment_text = format!(
                    "FunctionCall Mutator: replaced '{}' with '{}'",
                    original_node_s, new_node_s
                );
                if let Ok(comment_node) = new_comment_node(&comment_text) {
                    self.comment_node = Some(comment_node);
                }

                // We may not get a good id out of the new node.  The FunctionCall mutation replaces
                // a function call with an argument to the function.
                mutation_result.mutated_node_id = if node.is_object() {
                    node.get_int_for_key("id").map(|id| id as u64)
                } else {
                    None
                };

                let byte_array = hasher.finish()?;
                mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

                return Ok(mutation_result);
            }
        }
        Err(MutagenyxError::MalformedNode(
            String::from("FunctionCall"),
            String::from("arguments"),
        ))
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::FunctionCall)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Implements the function call argument swap mutation algorithm.
///
/// The mutator should identify function call expressions where the function call contains
/// at least two arguments of the same type.  The mutator will swap the two arguments.
struct SwapFunctionArgumentsMutator {
    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl SwapFunctionArgumentsMutator {
    /// Create the mutator object.
    pub fn new() -> SwapFunctionArgumentsMutator {
        SwapFunctionArgumentsMutator { comment_node: None }
    }
}

impl Mutator<SolidityAST> for SwapFunctionArgumentsMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "FunctionCall" {
                if let Some(arguments_node) = node.get("arguments") {
                    if let Some(arguments_array) = arguments_node.as_array() {
                        if arguments_array.len() > 1 {
                            // Now check to see if we have two nodes of the same type.  If we have
                            // two nodes of the same type then we can swap the arguments.
                            let mut type_map: HashMap<&str, i32> = HashMap::new();
                            for value in arguments_array {
                                if let Some(type_descriptions_node) = value.get("typeDescriptions")
                                {
                                    if let Some(type_string) =
                                        type_descriptions_node.get_str_for_key("typeString")
                                    {
                                        if type_map.contains_key(type_string) {
                                            let counter = type_map.get_mut(type_string).unwrap();
                                            *counter += 1;
                                        } else {
                                            type_map.insert(type_string, 1);
                                        }
                                    }
                                }
                            }

                            for (_key, value) in type_map {
                                if value >= 2 {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Replace previously existing comment.
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        // We have the FunctionCall node with arguments of the same type. Iterate and find
        // nodes of the same type so that we can swap them.
        if let Some(mut arguments_node) = node.take_value_for_key("arguments") {
            if let Some(arguments_array) = arguments_node.as_array_mut() {
                let mut arg_map: HashMap<&str, Vec<IndexedNode>> = HashMap::new();
                for (index, value) in arguments_array.iter().enumerate() {
                    if let Some(type_descriptions_node) = value.get("typeDescriptions") {
                        if let Some(type_string) =
                            type_descriptions_node.get_str_for_key("typeString")
                        {
                            if arg_map.contains_key(type_string) {
                                let list = arg_map.get_mut(type_string).unwrap();
                                list.push(IndexedNode::new(index, value.clone()));
                            } else {
                                arg_map.insert(
                                    type_string,
                                    vec![IndexedNode::new(index, value.clone())],
                                );
                            }
                        }
                    }
                }

                // Attempt to randomly select a pair of args from the arg_map.  We do this by
                // putting the keys in the map that have a list with two or more arguments into
                // a list and then randomly indexing into the list to select a key.
                let mut list_list: Vec<Vec<IndexedNode>> = vec![];
                for (_key, value) in arg_map {
                    if value.len() >= 2 {
                        list_list.push(value);
                    }
                }

                let list_index = (rand.next_u64() % list_list.len() as u64) as usize;
                let node_list = &list_list[list_index];
                let in1 = &node_list[0];
                let in2 = &node_list[1];

                hasher.update(&list_index.to_ne_bytes())?;

                // pretty print the node contents first before swapping. We need these strings
                // for the comment node.
                let in1_node_s = pretty_print_node(&in1.node);
                let in2_node_s = pretty_print_node(&in2.node);

                arguments_array.remove(in1.index);
                arguments_array.insert(in1.index, in2.node.clone());
                arguments_array.remove(in2.index);
                arguments_array.insert(in2.index, in1.node.clone());
                node.set_node_for_key("arguments", arguments_node);

                let comment_text = format!(
                    "SwapFunctionArguments Mutator: switched '{}' for '{}'",
                    in1_node_s, in2_node_s
                );
                if let Ok(comment_node) = new_comment_node(&comment_text) {
                    self.comment_node = Some(comment_node);
                }

                if let Some(id) = node.get_int_for_key("id") {
                    mutation_result.mutated_node_id = Some(id as u64);
                }

                let byte_array = hasher.finish()?;
                mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

                return Ok(mutation_result);
            }
        }
        Err(MutagenyxError::MalformedNode(
            String::from("FunctionCall"),
            String::from("arguments"),
        ))
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::SwapFunctionArguments)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Implement the IfStatement mutation algorithm.
///
/// The algorithm will randomly choose between three possible mutations:
/// * The algorithm replaces the condition of the if statement with `true`.
/// * The algorithm replaces the condition of the if statement with `false`.
/// * The algorithm replaces the condition (called c) of the if statement with `!(c)`.
struct IfStatementMutator {
    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl IfStatementMutator {
    /// Create the new if-statement mutator.
    pub fn new() -> IfStatementMutator {
        IfStatementMutator { comment_node: None }
    }
}

impl Mutator<SolidityAST> for IfStatementMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "IfStatement" {
                if let Some(condition_node) = node.get("condition") {
                    if !condition_node.is_null() {
                        return true;
                    }
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Remove previously existing comment.
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        let original_condition_node_s = if let Some(condition_node) = node.get("condition") {
            pretty_print_node(condition_node)
        } else {
            log::info!("IfStatement mutator could not find condition node.");
            return Err(MutagenyxError::MalformedNode(
                String::from("IfStatement"),
                String::from("condition"),
            ));
        };

        // Randomly choose between three possible mutations:
        // * Replace condition with true.
        // * Replace condition with false.
        // * Replace condition (called c) with !(c) (ie the negation).
        match rand.next_u64() % 3_u64 {
            0 => {
                hasher.update(&[0])?;
                // Replace the condition with `true`.
                let bool_node = match new_boolean_literal_node(true) {
                    Ok(n) => n,
                    Err(_e) => return Err(MutagenyxError::UnableToGenerateNode("boolean literal")),
                };
                node.set_node_for_key("condition", bool_node);
            }
            1 => {
                hasher.update(&[1])?;
                // Replace the condition with `false`.
                let bool_node = match new_boolean_literal_node(false) {
                    Ok(n) => n,
                    Err(_e) => return Err(MutagenyxError::UnableToGenerateNode("boolean literal")),
                };
                node.set_node_for_key("condition", bool_node);
            }
            2 => {
                hasher.update(&[2])?;
                // Replace the condition (called c) with !(c).
                if let Some(condition_node) = node.take_value_for_key("condition") {
                    // Put the existing condition into an array.
                    let components_array: Vec<SolidityAST> = vec![condition_node];

                    // Put the array into a TupleExpression node.
                    let tuple_node = match new_tuple_expression_node(components_array) {
                        Ok(n) => n,
                        Err(_e) => {
                            return Err(MutagenyxError::UnableToGenerateNode("tuple expression"))
                        }
                    };

                    // Wrap the TupleExpression node in a UnaryOp (! TupleExpression).
                    let not_node = match new_unary_op_node("!", true, tuple_node) {
                        Ok(n) => n,
                        Err(_e) => {
                            return Err(MutagenyxError::UnableToGenerateNode("unary operator"))
                        }
                    };

                    node.set_node_for_key("condition", not_node);
                }
            }
            _ => (),
        }

        let new_condition_node_s = if let Some(condition_node) = node.get("condition") {
            pretty_print_node(condition_node)
        } else {
            log::info!("IfStatement mutator can not find condition node after mutation.");
            return Err(MutagenyxError::MalformedNode(
                String::from("IfStatement"),
                String::from("condition"),
            ));
        };

        let comment_text = format!(
            "IfStatement Mutator: changed condition '{}' to '{}'",
            original_condition_node_s, new_condition_node_s
        );
        if let Ok(comment_node) = new_comment_node(&comment_text) {
            self.comment_node = Some(comment_node);
        }

        mutation_result.mutated_node_id = node.get_int_for_key("id").map(|id| id as u64);

        let byte_array = hasher.finish()?;
        mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

        Ok(mutation_result)
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::IfStatement)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Implement the Integer mutation algorithm:
///
/// Randomly selects one from the following:
/// * Adds one to integer constant.
/// * Subtracts one from integer constant.
/// * Generates a random value.
struct IntegerMutator {
    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl IntegerMutator {
    /// Create a new integer mutator.
    pub fn new() -> IntegerMutator {
        IntegerMutator { comment_node: None }
    }
}

impl Mutator<SolidityAST> for IntegerMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        // We look for a Literal node with an integer literal, not a floating point number.
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "Literal" {
                if let Some(kind) = node.get_str_for_key("kind") {
                    if kind == "number" {
                        if let Some(value) = node.get_str_for_key("value") {
                            let text = String::from(value);
                            // Search for a . in the string which indicates a floating point number.
                            let find_result = text.find('.');
                            if find_result.is_none() {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Remove previous comment.
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        let mut original_value_s = String::new();
        let mut new_value_s = String::new();

        match rand.next_u64() % 3_u64 {
            0 => {
                hasher.update(&[0])?;
                // Add one to the integer constant.
                if let Some(value) = node.get_str_for_key("value") {
                    let value_string = value.to_string();
                    original_value_s = value_string.clone();
                    let mut my_integer = value_string.parse::<i64>().unwrap();
                    my_integer += 1;
                    new_value_s = my_integer.to_string();
                    node.set_str_for_key("value", my_integer.to_string().as_str());
                }
            }
            1 => {
                hasher.update(&[1])?;
                // Subtract one from the integer constant.
                if let Some(value) = node.get_str_for_key("value") {
                    let value_string = value.to_string();
                    original_value_s = value_string.clone();
                    let mut my_integer = value_string.parse::<i64>().unwrap();
                    my_integer -= 1;
                    new_value_s = my_integer.to_string();
                    node.set_str_for_key("value", my_integer.to_string().as_str());
                }
            }
            2 => {
                hasher.update(&[2])?;
                if let Some(value) = node.get_str_for_key("value") {
                    original_value_s = String::from(value);
                }

                // Generate a random number.
                let value = rand.next_u64();
                new_value_s = value.to_string();
                node.set_str_for_key("value", value.to_string().as_str());
            }
            _ => (),
        }

        let comment_text = format!(
            "Integer Mutator: changed '{}' to '{}'",
            original_value_s, new_value_s
        );
        if let Ok(comment_node) = new_comment_node(&comment_text) {
            self.comment_node = Some(comment_node);
        }

        mutation_result.mutated_node_id = node.get_int_for_key("id").map(|id| id as u64);

        let byte_array = hasher.finish()?;
        mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

        Ok(mutation_result)
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::Integer)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Implement the operator swap mutation algorithm
///
/// The algorithm swaps the left and right hand sides of the arguments
/// to a BinaryOperation.  The operator of the BinaryOperation must
/// be in the list of non-commutative operators: [-, /, %, **, >, <, <=, >=, <<, >>]
struct SwapOperatorArgumentsMutator {
    valid_operators: Vec<&'static str>,

    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl SwapOperatorArgumentsMutator {
    /// Create a new mutator.
    fn new() -> SwapOperatorArgumentsMutator {
        SwapOperatorArgumentsMutator {
            valid_operators: non_commutative_operators(),
            comment_node: None,
        }
    }
}

impl Mutator<SolidityAST> for SwapOperatorArgumentsMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "BinaryOperation" {
                if let Some(operator_string) = node.get_str_for_key("operator") {
                    if self.valid_operators.contains(&operator_string) {
                        return true;
                    }
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        _rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Remove previous comment.
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        if let Some(left_expr) = node.take_value_for_key("leftExpression") {
            return if let Some(right_expr) = node.take_value_for_key("rightExpression") {
                let left_expr_s = pretty_print_node(&left_expr);
                let right_expr_s = pretty_print_node(&right_expr);

                hasher.update(left_expr_s.as_bytes())?;
                hasher.update(right_expr_s.as_bytes())?;

                node.set_node_for_key("leftExpression", right_expr);
                node.set_node_for_key("rightExpression", left_expr);

                let comment_text = format!(
                    "SwapOperatorArguments Mutator: switched '{}' and '{}'",
                    left_expr_s, right_expr_s
                );
                if let Ok(comment_node) = new_comment_node(&comment_text) {
                    self.comment_node = Some(comment_node);
                }

                if let Some(id) = node.get_int_for_key("id") {
                    mutation_result.mutated_node_id = Some(id as u64);
                }

                let byte_array = hasher.finish()?;
                mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

                Ok(mutation_result)
            } else {
                Err(MutagenyxError::MalformedNode(
                    String::from("BinaryOperation"),
                    String::from("rightExpression"),
                ))
            };
        }
        Err(MutagenyxError::MalformedNode(
            String::from("BinaryOperation"),
            String::from("leftExpression"),
        ))
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::SwapOperatorArguments)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Implement line swap mutation algorithm.
///
/// The algorithm chooses two lines from a block of code and attempts to randomly swap two of
/// the lines.  Since function return statements affect how a program compiles, the algorithm
/// will explicitly not swap lines with return statements.
struct SwapLinesMutator {
    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl SwapLinesMutator {
    /// Create the new lines-swap mutator.
    pub fn new() -> SwapLinesMutator {
        SwapLinesMutator { comment_node: None }
    }
}

impl Mutator<SolidityAST> for SwapLinesMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        // We need a function definition with at least two body statements.
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "Block" {
                if let Some(statements_node) = node.get("statements") {
                    if let Some(statements_array) = statements_node.as_array() {
                        if statements_array.len() >= 2 {
                            let mut found_return_statement = false;
                            for value in statements_array {
                                if let Some(value_node_type) = value.get_str_for_key("nodeType") {
                                    if value_node_type == "Return" {
                                        found_return_statement = true;
                                        break;
                                    }
                                }
                            }

                            // If the body of the function def has a return statement, then there
                            // must be at least 3 statements in the body in order to swap (but not
                            // swap a return statement) statements.  If there are no return statements
                            // then we can just go ahead and swap.
                            if !found_return_statement || statements_array.len() >= 3 {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Replace previous comment.
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        if let Some(mut statements_node) = node.take_value_for_key("statements") {
            if let Some(statements_array) = statements_node.as_array_mut() {
                // Randomly pick a first node.
                let mut first_index: usize;
                loop {
                    first_index = (rand.next_u64() % statements_array.len() as u64) as usize;
                    if let Some(node_type) =
                        statements_array[first_index].get_str_for_key("nodeType")
                    {
                        if node_type == "Return" {
                            continue;
                        }
                    }
                    break;
                }

                hasher.update(&first_index.to_ne_bytes())?;

                // Try to randomly pick a second node.
                let mut second_index: usize;
                loop {
                    second_index = (rand.next_u64() % statements_array.len() as u64) as usize;
                    if second_index == first_index {
                        continue;
                    }
                    if let Some(node_type) =
                        statements_array[second_index].get_str_for_key("nodeType")
                    {
                        if node_type == "Return" {
                            continue;
                        }
                    }
                    break;
                }

                hasher.update(&second_index.to_ne_bytes())?;

                let larger_index = if first_index >= second_index {
                    first_index
                } else {
                    second_index
                };

                let smaller_index = if first_index >= second_index {
                    second_index
                } else {
                    first_index
                };

                let larger_node = statements_array.remove(larger_index);
                let smaller_node = statements_array.remove(smaller_index);

                let larger_node_s = pretty_print_node(&larger_node);
                let smaller_node_s = pretty_print_node(&smaller_node);

                statements_array.insert(smaller_index, larger_node);
                statements_array.insert(larger_index, smaller_node);
                node.set_node_for_key("statements", statements_node);

                let comment_text = format!(
                    "SwapLines Mutator: swapped line '{}' with line '{}'",
                    larger_node_s, smaller_node_s
                );
                if let Ok(comment_node) = new_comment_node(&comment_text) {
                    self.comment_node = Some(comment_node);
                }

                if let Some(id) = node.get_int_for_key("id") {
                    mutation_result.mutated_node_id = Some(id as u64);
                }

                let byte_array = hasher.finish()?;
                mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

                return Ok(mutation_result);
            }
        }
        Err(MutagenyxError::MalformedNode(
            String::from("Block"),
            String::from("statements"),
        ))
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::SwapLines)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Implements the Solidity require function mutation algorithm.
///
/// This mutator will replace the expression in the argument to the Solidity `require` function
/// with the logical negation of the expression.
///
/// # Example
///
/// ```solidity
/// require(a > b);
/// ```
///
/// would become
///
/// ```solidity
/// require(!(a > b))
/// ```
struct SolidityRequireMutator {
    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl SolidityRequireMutator {
    /// Create the new require mutator.
    pub fn new() -> SolidityRequireMutator {
        SolidityRequireMutator { comment_node: None }
    }
}

impl Mutator<SolidityAST> for SolidityRequireMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        // Check that the node is a 'FunctionCall' node, that the function call is the
        // `require` function, and that the function has an argument.
        return node.get_str_for_key("nodeType").map_or_else(
            || false,
            |n| {
                n == "FunctionCall"
                    && (node.get("expression").map_or_else(
                        || false,
                        |n| {
                            n.get_str_for_key("name")
                                .map_or_else(|| false, |name| name == "require")
                        },
                    ))
                    && !node
                        .get_array_for_key("arguments")
                        .map_or_else(|| false, |v| v.is_empty())
            },
        );
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        _: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Remove previous comment
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        let malformed_args_err = Err(MutagenyxError::MalformedNode(
            String::from("FunctionCall"),
            String::from("arguments"),
        ));

        let original_arguments_s = if let Some(arguments_node) = node.get("arguments") {
            if let Some(args_array) = arguments_node.as_array() {
                if !args_array.is_empty() {
                    let arg = &args_array[0];
                    pretty_print_node(arg)
                } else {
                    return malformed_args_err;
                }
            } else {
                return malformed_args_err;
            }
        } else {
            log::info!("SwapLines mutator unable to get arguments node.");
            return malformed_args_err;
        };

        // First create a Unary ! operation node.
        let new_node_str = "{\
            \"id\": 99999,
            \"isConstant\": false,
            \"isLValue\": false,
            \"isPure\": true,
            \"lValueRequested\": false,
            \"nodeType\": \"UnaryOperation\",
            \"operator\": \"!\",
            \"prefix\": true,
            \"typeDescriptions\": {
                \"typeIdentifier\": \"t_bool\",
                \"typeString\": \"bool\"
            }
        }";
        let mut new_node = match new_json_node(new_node_str) {
            Ok(v) => v,
            Err(_) => return Err(MutagenyxError::UnableToGenerateNode("boolean literal")),
        };

        // Create a Tuple node to hold the function argument
        let tuple_expression_str = "{\
             \"id\": 99996,
             \"isConstant\": false,
             \"isInlineArray\": false,
             \"isLValue\": false,
             \"isPure\": false,
             \"lValueRequested\": false,
             \"nodeType\": \"TupleExpression\",
             \"typeDescriptions\": {
                 \"typeIdentifier\": \"t_bool\",
                 \"typeString\": \"bool\"
             }
        }";

        let mut tuple_expression_node = match new_json_node(tuple_expression_str) {
            Ok(v) => v,
            Err(_) => return Err(MutagenyxError::UnableToGenerateNode("tuple expression")),
        };

        let components_str = "[]";
        let mut components_node = match new_json_node(components_str) {
            Ok(v) => v,
            Err(_) => return Err(MutagenyxError::UnableToGenerateNode("empty array")),
        };

        // Get the node from the arguments list.
        let arg = match node.take_argument(0) {
            Some(n) => n,
            _ => {
                log::info!("Arguments list does not contain valid node");
                return Err(MutagenyxError::MalformedNode(
                    String::from("FunctionCall"),
                    String::from("arguments"),
                ));
            }
        };

        let components_array = match components_node.as_array_mut() {
            Some(v) => v,
            _ => return Err(MutagenyxError::IncorrectJSONNodeType("components", "array")),
        };

        components_array.push(arg);
        tuple_expression_node["components"] = components_node;

        // Put the node into the generated UnaryOp node.
        new_node["subExpression"] = tuple_expression_node;

        let new_arguments_node_s = pretty_print_node(&new_node);

        hasher.update(new_arguments_node_s.as_bytes())?;

        node.set_node_for_key_at_index("arguments", 0, new_node);

        let comment_text = format!(
            "Require Mutator: Changing '{}' to '{}'",
            original_arguments_s, new_arguments_node_s
        );
        if let Ok(comment_node) = new_comment_node(&comment_text) {
            self.comment_node = Some(comment_node);
        }

        mutation_result.mutated_node_id = node.get_int_for_key("id").map(|id| id as u64);

        let byte_array = hasher.finish()?;
        mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

        Ok(mutation_result)
    }

    fn implements(&self) -> MutationType {
        MutationType::Solidity(SolidityMutation::Require)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Implements the unchecked block mutation algorithm for Solidity programs.
///
/// The algorithm selects a random expression statement from a Block and replaces
/// the statement with unchecked{ statement; }.  The algorithm will not select a
/// statement that contains a Return.
struct SolidityUncheckedBlockMutator {
    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl SolidityUncheckedBlockMutator {
    /// Create a new unchecked-block node.
    pub fn new() -> SolidityUncheckedBlockMutator {
        SolidityUncheckedBlockMutator { comment_node: None }
    }
}

impl Mutator<SolidityAST> for SolidityUncheckedBlockMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "Block" {
                if let Some(statements_node) = node.get("statements") {
                    if let Some(statements_array) = statements_node.as_array() {
                        if !statements_array.is_empty() {
                            let mut have_return_statement = false;
                            let mut have_unchecked_block_statement = false;
                            let mut required_length: usize = 1;
                            for value in statements_array {
                                if let Some(value_node_type) = value.get_str_for_key("nodeType") {
                                    if (!have_return_statement) && value_node_type == "Return" {
                                        have_return_statement = true;
                                        required_length += 1;
                                    }
                                    if (!have_unchecked_block_statement)
                                        && value_node_type == "UncheckedBlock"
                                    {
                                        have_unchecked_block_statement = true;
                                        required_length += 1;
                                    }

                                    if have_return_statement && have_unchecked_block_statement {
                                        break;
                                    }
                                }
                            }

                            // If the Block node has a return statement and/or an UncheckedBlock statement,
                            // we need at least one more statement than block + unchecked block
                            // in order for the algorithm to work.  We do not wrap a return statement
                            // or an unchecked block statement in unchecked{}.
                            if statements_array.len() >= required_length {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Replace previous comment.
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        let mut hasher = Hasher::new(MessageDigest::sha256())?;

        if let Some(mut statements_node) = node.take_value_for_key("statements") {
            if let Some(statements_array) = statements_node.as_array_mut() {
                // Pick a random statement, but avoid Return statements.
                let mut node_to_wrap: SolidityAST;
                let mut index: usize;
                loop {
                    index = (rand.next_u64() % statements_array.len() as u64) as usize;
                    node_to_wrap = statements_array.remove(index);
                    if let Some(node_type) = node_to_wrap.get_str_for_key("nodeType") {
                        if node_type == "Return" || node_type == "UncheckedBlock" {
                            statements_array.insert(index, node_to_wrap);
                            continue;
                        }
                    }
                    break;
                }

                hasher.update(&index.to_ne_bytes())?;

                let node_to_wrap_id = node_to_wrap.get_int_for_key("id").unwrap_or(9999999);

                let node_to_wrap_s = pretty_print_node(&node_to_wrap);

                let wrapped_array = vec![node_to_wrap];
                let wrapped_node =
                    match new_unchecked_block_node(wrapped_array, node_to_wrap_id as u64) {
                        Ok(n) => n,
                        Err(_e) => {
                            return Err(MutagenyxError::UnableToGenerateNode("unchecked block"))
                        }
                    };

                let wrapped_node_s = pretty_print_node(&wrapped_node);

                statements_array.insert(index, wrapped_node);
                node.set_node_for_key("statements", statements_node);

                let comment_text = format!(
                    "UncheckedBlock Mutator: Changing '{}' to '{}'",
                    node_to_wrap_s, wrapped_node_s
                );
                if let Ok(comment_node) = new_comment_node(&comment_text) {
                    self.comment_node = Some(comment_node);
                }

                mutation_result.mutated_node_id = Some(node_to_wrap_id as u64);

                let byte_array = hasher.finish()?;
                mutation_result.random_behavior_hash = Some(hex::encode(byte_array));

                return Ok(mutation_result);
            }
        }
        Err(MutagenyxError::MalformedNode(
            String::from("Block"),
            String::from("statements"),
        ))
    }

    fn implements(&self) -> MutationType {
        MutationType::Solidity(SolidityMutation::UncheckedBlock)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Implements the eliminate-delegate-call mutation algorithm for Solidity programs.
///
/// The algorithm finds MemberAccess nodes whose expression sub-node has a memberName key
/// with the value `delegatecall`. The algorithm replaces the `delegatecall` with `call`.
struct SolidityElimDelegateCallMutator {
    /// Information about the mutation.
    comment_node: Option<SolidityAST>,
}

impl SolidityElimDelegateCallMutator {
    /// Create a new elim-delegatecall mutator.
    pub fn new() -> SolidityElimDelegateCallMutator {
        SolidityElimDelegateCallMutator { comment_node: None }
    }
}

impl Mutator<SolidityAST> for SolidityElimDelegateCallMutator {
    fn is_mutable_node(&mut self, node: &SolidityAST, _rand: &mut Pcg64) -> bool {
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "MemberAccess" {
                if let Some(member_name_str) = node.get_str_for_key("memberName") {
                    if member_name_str == "delegatecall" {
                        return true;
                    }
                }
            }
        }
        false
    }

    fn mutate(
        &mut self,
        node: &mut SolidityAST,
        _rand: &mut Pcg64,
    ) -> Result<MutatorResult, MutagenyxError> {
        // Replace previous comment
        self.comment_node = None;

        let mut mutation_result = MutatorResult::new();
        mutation_result.mutation_type = Some(self.implements());

        node.set_str_for_key("memberName", "call");

        let comment_text =
            String::from("ElimDelegateCall Mutator: replace 'delegatecall' with 'call'");
        if let Ok(comment_node) = new_comment_node(&comment_text) {
            self.comment_node = Some(comment_node);
        }

        mutation_result.mutated_node_id = node.get_int_for_key("id").map(|id| id as u64);

        Ok(mutation_result)
    }

    fn implements(&self) -> MutationType {
        MutationType::Solidity(SolidityMutation::ElimDelegateCall)
    }

    fn get_comment_node(&self) -> Option<SolidityAST> {
        self.comment_node.clone()
    }
}

/// Implement the [`MutatorFactory<T>`] trait to have an interface for getting mutators for requested
/// mutation algorithms.
pub struct SolidityMutatorFactory {}

impl MutatorFactory<SolidityAST> for SolidityMutatorFactory {
    fn mutator_for(&self, mutation_type: &MutationType) -> Option<Box<dyn Mutator<SolidityAST>>> {
        match mutation_type {
            MutationType::Generic(t) => match t {
                GenericMutation::ArithmeticBinaryOp => Some(Box::new(BinaryOpMutator::new(
                    arithmetic_operators(),
                    MutationType::Generic(GenericMutation::ArithmeticBinaryOp),
                ))),
                GenericMutation::LogicalBinaryOp => Some(Box::new(BinaryOpMutator::new(
                    logical_operators(),
                    MutationType::Generic(GenericMutation::LogicalBinaryOp),
                ))),
                GenericMutation::BitwiseBinaryOp => Some(Box::new(BinaryOpMutator::new(
                    bitwise_operators(),
                    MutationType::Generic(GenericMutation::BitwiseBinaryOp),
                ))),
                GenericMutation::BitshiftBinaryOp => Some(Box::new(BinaryOpMutator::new(
                    bitshift_operators(),
                    MutationType::Generic(GenericMutation::BitshiftBinaryOp),
                ))),
                GenericMutation::ComparisonBinaryOp => Some(Box::new(BinaryOpMutator::new(
                    comparison_operators(),
                    MutationType::Generic(GenericMutation::ComparisonBinaryOp),
                ))),
                GenericMutation::Assignment => Some(Box::new(AssignmentMutator::new())),
                GenericMutation::DeleteStatement => Some(Box::new(DeleteStatementMutator::new())),
                GenericMutation::FunctionCall => Some(Box::new(FunctionCallMutator::new())),
                GenericMutation::SwapFunctionArguments => {
                    Some(Box::new(SwapFunctionArgumentsMutator::new()))
                }
                GenericMutation::IfStatement => Some(Box::new(IfStatementMutator::new())),
                GenericMutation::Integer => Some(Box::new(IntegerMutator::new())),
                GenericMutation::SwapOperatorArguments => {
                    Some(Box::new(SwapOperatorArgumentsMutator::new()))
                }
                GenericMutation::SwapLines => Some(Box::new(SwapLinesMutator::new())),
                GenericMutation::UnaryOp => Some(Box::new(UnaryOpMutator::new())),
            },
            MutationType::Solidity(t) => match t {
                SolidityMutation::Require => Some(Box::new(SolidityRequireMutator::new())),
                SolidityMutation::UncheckedBlock => {
                    Some(Box::new(SolidityUncheckedBlockMutator::new()))
                }
                SolidityMutation::ElimDelegateCall => {
                    Some(Box::new(SolidityElimDelegateCallMutator::new()))
                }
            },
        }
    }
}
