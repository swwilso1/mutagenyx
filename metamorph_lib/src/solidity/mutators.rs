//! The `solidity::mutators` module provides the objects that implement the mutation algorithms
//! for the Solidity ASTs.  The module also provides the factory that implements [`MutatorFactory<T>`].

use crate::error::MetamorphError;
use crate::json::{new_json_node, JSONMutate};
use crate::mutation::{GenericMutation, MutationType, SolidityMutation};
use crate::mutator::{Mutator, MutatorFactory};
use crate::node_printer_helpers::traverse_sub_node_and_print;
use crate::operators::*;
use crate::solidity::ast::{SolidityAST, SolidityASTApi};
use crate::solidity::pretty_printer::SolidityNodePrinterFactory;
use crate::PrettyPrinter;
use num::Integer;
use rand::seq::SliceRandom;
use rand::{Rng, RngCore};
use rand_pcg::*;
use rustc_serialize::hex::ToHex;
use serde_json::json;
use std::collections::HashMap;
use std::fmt;

/// Return a new integer literal node representing an integer literal number.
///
/// # Argument
/// * `value` - The number that the node should contain.
fn new_integer_constant_node<I: Integer + fmt::Display>(
    value: I,
) -> Result<SolidityAST, MetamorphError> {
    let value_str = value.to_string();
    let hex_value_str = value_str.as_bytes().to_hex();
    let node_string = format!(
        "{{
        \"hexValue\": \"{hex_value_str}\",
        \"id\": 9999997,
        \"isConstant\": false,
        \"isLValue\": false,
        \"isPure\": true,
        \"kind\": \"number\",
        \"lValueRequested\": false,
        \"nodeType\": \"Literal\",
        \"typeDescriptions\": {{
            \"typeIdentifier\": \"t_rational_{value}_by_1\",
            \"typeString\": \"int_const {value}\"
        }},
        \"value\": \"{value}\"
        }}
    "
    );
    new_json_node(&node_string)
}

/// Return a new boolean literal node.
///
/// # Argument
///
/// * `value` - The boolean value to store in the node.
fn new_boolean_literal_node(value: bool) -> Result<SolidityAST, MetamorphError> {
    let value_str = value.to_string();
    let hex_value_str = value_str.as_bytes().to_hex();
    let node_string = format!(
        "{{\
        \"hexValue\": \"{hex_value_str}\",
        \"id\": 9999998,
        \"isConstant\": false,
        \"isLValue\": false,
        \"isPure\": true,
        \"kind\": \"bool\",
        \"lValueRequested\": false,
        \"nodeType\": \"Literal\",
        \"typeDescriptions\": {{
            \"typeIdentifier\": \"t_bool\",
            \"typeString\": \"bool\"
        }},
        \"value\": \"{value}\"
    }}"
    );
    new_json_node(&node_string)
}

/// Return a new comment node.
///
/// **Important**: Comment nodes do not naturally occur in Solidity AST files (not yet) and so
/// any AST with a comment node no longer conforms to the standard AST format generated by the
/// Solidity compiler.
///
/// # Arguments
///
/// * `text` - The reference to the string content that contains the text to add to the comment.
fn new_comment_node(text: &str) -> Result<SolidityAST, MetamorphError> {
    let text_node = json![text];

    let node_string = format!(
        "{{\
            \"id\": 9999997,
            \"isConstant\": false,
            \"isLValue\": false,
            \"isPure\": false,
            \"lValueRequested\": false,
            \"nodeType\": \"Comment\",
            \"text\": null
        }}"
    );

    let mut node = new_json_node(&node_string)?;
    node.set_node_for_key("text", text_node);
    Ok(node)
}

/// Helper function to generate a new unary operator node.
///
/// # Arguments
///
/// * `operator` - The text of the operator (!, --, ++, ~, etc...).
/// * `prefix` - True if the unary operator is a prefix operator and false for postfix.
/// * `sub_expression` - The node to which the operator applies.
fn new_unary_op_node(
    operator: &str,
    prefix: bool,
    sub_expression: SolidityAST,
) -> Result<SolidityAST, MetamorphError> {
    let node_string = format!(
        "{{\
            \"id\": 9999996,
            \"isConstant\": false,
            \"isLValue\": false,
            \"isPure\": false,
            \"lValueRequested\": false,
            \"nodeType\": \"UnaryOperation\",
            \"operator\": \"{operator}\",
            \"prefix\": {prefix},
            \"subExpression\": null
        }}"
    );

    let mut node = new_json_node(&node_string)?;
    node.set_node_for_key("subExpression", sub_expression);
    Ok(node)
}

/// Helper function for generating a new TupleExpression.
///
/// # Arguments
///
/// * `array` - An array of SolidityAST nodes to place in the TupleExpression components array.
fn new_tuple_expression_node(array: Vec<SolidityAST>) -> Result<SolidityAST, MetamorphError> {
    let node_array = json![array];

    let node_str = format!(
        "{{\
            \"id\": 9999995,
            \"isConstant\": false,
            \"IsInlineArray\": false,
            \"isLValue\": false,
            \"isPure\": false,
            \"lValueRequested\": false,
            \"nodeType\": \"TupleExpression\",
            \"components\": null
        }}"
    );

    let mut tuple_node = new_json_node(&node_str)?;
    tuple_node.set_node_for_key("components", node_array);
    Ok(tuple_node)
}

/// Helper function to wrap an array of nodes in a Solidity UncheckedBlock node.
///
/// # Arguments
///
/// * `array` - The vector of [`SolidityAST`] nodes to place in the UncheckedBlock
fn new_unchecked_block_node(array: Vec<SolidityAST>) -> Result<SolidityAST, MetamorphError> {
    let node_array = json![array];

    let node_str = format!(
        "{{\
            \"id\": 9999994,
            \"nodeType\": \"UncheckedBlock\",
            \"statements\": null
        }}"
    );

    let mut unchecked_node = new_json_node(&node_str)?;
    unchecked_node.set_node_for_key("statements", node_array);
    Ok(unchecked_node)
}

/// The object that implements mutations for binary expressions.
///
/// Multiple mutation algorithms operate on binary expressions.  Each of those
/// mutation algorithms uses a subset of the available binary operators.  This
/// one structure/class provides the functionality to implement these different
/// binary expression mutations.
struct BinaryOpMutator {
    /// A list of operators valid for the binary expression
    operators: Vec<&'static str>, //Vec<String>,

    /// The mutation algorithm implemented by the mutator.
    mutation_type: MutationType,
}

impl BinaryOpMutator {
    /// Return a new instance of the mutator.
    ///
    /// # Arguments
    ///
    /// * `operators` - the list of operators for the mutator
    /// * `mutation_type` - the mutation algorithm implemented by the mutator
    pub fn new(
        operators: Vec<&'static str>, /* Vec<String> */
        mutation_type: MutationType,
    ) -> BinaryOpMutator {
        BinaryOpMutator {
            operators,
            mutation_type,
        }
    }
}

impl Mutator<SolidityAST> for BinaryOpMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        // First check to see if the node in the AST is a "BinaryOperation" node.
        if let Some(n) = node.get_str_for_key("nodeType") {
            if n == "BinaryOperation" {
                // Get the operator from the node and see if the operator is in the mutator's
                // list of supported operators. The mutator can mutate the node if it supports
                // the node's operator.
                if let Some(op) = node.get_str_for_key("operator") {
                    return self.operators.contains(&op);
                }
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, rand: &mut Pcg64) {
        if let Some(original_operator) = node.get_str_for_key("operator") {
            // Get the original operator so that we can use it to compare for the
            // randomly chosen new operator. We do not want to replace the original operator
            // with itself, just by randomly selecting the same operator from the operator list.
            let mut chosen_operator = match self.operators.choose(rand) {
                Some(o) => o,
                None => return,
            };

            // If we chose the original operator, keep choosing until we get a different operator.
            while original_operator == *chosen_operator {
                chosen_operator = match self.operators.choose(rand) {
                    Some(o) => o,
                    None => return,
                };
            }

            // Insert the new operator into the node.
            node.set_str_for_key("operator", &chosen_operator);
        }
    }

    fn implements(&self) -> MutationType {
        self.mutation_type
    }
}

/// The structure/class that implements mutations for unary expressions.
struct UnaryOpMutator {
    /// A list of operators usable as prefix operators.
    prefix_operators: Vec<&'static str>,

    /// A list of operators usable as postfix operators.
    postfix_operators: Vec<&'static str>,
}

impl UnaryOpMutator {
    /// Create a new unary expression mutator.
    pub fn new() -> UnaryOpMutator {
        UnaryOpMutator {
            prefix_operators: prefix_operators(),
            postfix_operators: postfix_operators(),
        }
    }
}

impl Mutator<SolidityAST> for UnaryOpMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        // First check to see if the node is a 'UnaryOperation' node.
        if let Some(n) = node.get_str_for_key("nodeType") {
            if n == "UnaryOperation" {
                // Now check the 'prefix' member of the node and if the node is a prefix operation
                // use the prefix operator list and otherwise use the postfix operator list.
                let operator_list = match node.get_bool_for_key("prefix") {
                    Some(p) => {
                        if p {
                            &self.prefix_operators
                        } else {
                            &self.postfix_operators
                        }
                    }
                    _ => {
                        log::info!(
                            "Found a UnaryOperator node with no prefix information: {:?}",
                            node
                        );
                        return false;
                    }
                };

                // Check to see if the operator in the node is in the operator list for the
                // mutator
                if let Some(op) = node.get_str_for_key("operator") {
                    return operator_list.contains(&op);
                }
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, rand: &mut Pcg64) {
        // Determine if the node is a prefix/postfix operation and then use the prefix or
        // postfix operator list.
        let operator_list = match node.get_bool_for_key("prefix") {
            Some(p) => {
                if p {
                    &self.prefix_operators
                } else {
                    &self.postfix_operators
                }
            }
            _ => {
                log::info!(
                    "Mutate found a UnaryOperator node with no prefix information: {:?}",
                    node
                );
                return;
            }
        };

        // Get the original operator that we can use to compare to the new operator that we select.
        // If the operator choice selects the same operator as the original, then we want to keep
        // selecting operators until we have a different operator.
        let original_operator = match node.get_str_for_key("operator") {
            Some(o) => o,
            None => "",
        };

        // Choose a new operator.
        let mut chosen_operator = match operator_list.choose(rand) {
            Some(o) => o,
            None => return,
        };

        // If the operators match, choose another operator until they no longer match.
        while original_operator == *chosen_operator {
            chosen_operator = match operator_list.choose(rand) {
                Some(o) => o,
                None => return,
            };
        }

        node.set_str_for_key("operator", &chosen_operator);
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::UnaryOp)
    }
}

/// Implements the assignment mutation algorithm.
///
/// For a given Assigment expression, the algorithm replaces the right-hand side of the expression
/// with a type correct random value.  Specifically the algorithm operates on assignments to
/// integer, unsigned integer, and boolean variables.  For signed and unsigned integers, the
/// algorithm will recognize the range of the type and generate random numbers that lie in the
/// range.  Since rust only supports a maximum of 128-bit signed and unsigned integers, Solidity
/// types larger than that will only receive a random number in the 128-bit range.
struct AssignmentMutator {}

impl AssignmentMutator {
    /// Create the new mutator.
    pub fn new() -> AssignmentMutator {
        AssignmentMutator {}
    }
}

impl Mutator<SolidityAST> for AssignmentMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        // First check to see if the node is an `Assignment` node.
        if let Some(n) = node.get_str_for_key("nodeType") {
            if n == "Assignment" {
                // Now recover the type information from the node.
                let type_description_node = match node.borrow_value_for_key("typeDescriptions") {
                    Some(n) => n,
                    _ => {
                        log::info!("Assignment node has no type description object");
                        return false;
                    }
                };

                let type_string = match type_description_node.get_str_for_key("typeString") {
                    Some(s) => s,
                    _ => {
                        log::info!("Assignment node's type description has no type string");
                        return false;
                    }
                };

                if type_string.len() < 3 {
                    return false;
                }

                let first_three_chars = &type_string[..3];

                return match first_three_chars {
                    "uin" => true,
                    "int" => true,
                    "boo" => true,
                    _ => false,
                };
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, rand: &mut Pcg64) {
        // Recover the type descriptions for the node.
        let type_description_node = match node.borrow_value_for_key("typeDescriptions") {
            Some(n) => n,
            _ => {
                log::info!("Assignment node has no type description object");
                return;
            }
        };

        let type_string = match type_description_node.get_str_for_key("typeString") {
            Some(s) => s,
            _ => {
                log::info!("Assignment node's type description has no type string");
                return;
            }
        };

        let first_three_chars = &type_string[..3];

        match first_three_chars {
            "int" => {
                let type_size_str = &type_string[3..];
                let mut type_size = type_size_str.parse::<u32>().unwrap();

                if type_size > 128 {
                    type_size = 128;
                }

                let lower_bound = -(2_i128.pow(type_size - 1)) as i128;
                let upper_bound = (2_i128.pow(type_size - 1)) as i128;
                let replacement_value = rand.gen_range(lower_bound, upper_bound);

                let new_node = match new_integer_constant_node(replacement_value) {
                    Ok(n) => n,
                    _ => return,
                };

                node.set_node_for_key("rightHandSide", new_node);
            }
            "uin" => {
                let type_size_str = &type_string[4..];
                let mut type_size = type_size_str.parse::<u32>().unwrap();

                if type_size > 128 {
                    type_size = 128;
                }

                let lower_bound = 0 as u128;
                let upper_bound: u128;
                if type_size < 128 {
                    upper_bound = 2_u128.pow(type_size) - 1;
                } else {
                    // 2.pow(128) - 1
                    upper_bound = 340282366920938463463374607431768211455u128;
                }
                let replacement_value = rand.gen_range(lower_bound, upper_bound);

                let new_node = match new_integer_constant_node(replacement_value) {
                    Ok(n) => n,
                    _ => return,
                };

                node.set_node_for_key("rightHandSide", new_node);
            }
            "boo" => {
                assert_eq!(type_string, "bool");
                let replacement_value = rand.gen_range(0, 1);
                let bool_literal: bool;
                if replacement_value == 0 {
                    bool_literal = false;
                } else {
                    bool_literal = true;
                }

                let new_node = match new_boolean_literal_node(bool_literal) {
                    Ok(n) => n,
                    _ => return,
                };

                node.set_node_for_key("rightHandSide", new_node);
            }
            _ => return,
        }
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::Assignment)
    }
}

/// Type that implements the DeleteStatement algorithm.
///
/// The algorithm chooses a random ExpressionStatement node in any Block and replaces that statement
/// with a comment node.
struct DeleteStatementMutator {}

impl Mutator<SolidityAST> for DeleteStatementMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        // We are looking for a Block node that has at least one ExpressionStatement
        // in the body of the function.
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "Block" {
                if let Some(statements_node) = node.borrow_value_for_key("statements") {
                    if let Some(statements_array) = statements_node.as_array() {
                        if statements_array.len() > 1 {
                            // The array needs to have at least one ExpressionStatement.
                            for value in statements_array {
                                if let Some(value_type) = value.get_str_for_key("nodeType") {
                                    if value_type == "ExpressionStatement" {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, rand: &mut Pcg64) {
        // We have a Block node that has a statements array with at least one
        // ExpressionStatement. Go through the statements and pick one randomly in order
        // to delete the statement.

        if let Some(mut statements_node) = node.take_value_for_key("statements") {
            if let Some(statements_array) = statements_node.as_array_mut() {
                let mut expression_statement_indexes: Vec<usize> = vec![];
                for (index, value) in statements_array.iter().enumerate() {
                    if value.is_object() {
                        if let Some(value_type) = value.get_str_for_key("nodeType") {
                            if value_type == "ExpressionStatement" {
                                expression_statement_indexes.push(index);
                            }
                        }
                    }
                }

                // Now pick a random index.
                let vector_index =
                    (rand.next_u64() % expression_statement_indexes.len() as u64) as usize;
                let value = statements_array.remove(expression_statement_indexes[vector_index]);

                // Now pretty-print the node so we can wrap the resulting string in a comment node.
                let mut contents = Vec::new();
                let mut printer = PrettyPrinter::new(4, 150);
                traverse_sub_node_and_print(
                    &mut printer,
                    &mut contents,
                    SolidityNodePrinterFactory {},
                    &value,
                );
                let s = core::str::from_utf8(contents.as_slice()).unwrap();

                let new_node = match new_comment_node(s) {
                    Ok(node) => node,
                    Err(_e) => return,
                };

                statements_array.insert(expression_statement_indexes[vector_index], new_node);

                node.set_node_for_key("statements", statements_node);
            }
        }
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::DeleteStatement)
    }
}

/// Helper struct for FunctionCall mutation algorithm.
///
/// The mutation algorithm keeps track of argument indexes and values with IndexedNode
/// objects.
struct IndexedNode {
    /// The index of the node in the function call arguments array.
    pub index: usize,

    /// A copy of the argument found at `index`.
    pub node: SolidityAST,
}

impl IndexedNode {
    /// Create a new IndexedNode object.
    ///
    /// # Arguments
    ///
    /// * `index` - The index of the node from the arguments array.
    /// * `node` - A copy of the node from the arguments array.
    fn new(index: usize, node: SolidityAST) -> IndexedNode {
        IndexedNode { index, node }
    }
}

/// Implements the FunctionCall mutation algorithm.
///
/// The algorithm selects a random function call and replaces the function call with one of the
/// arguments from the function call.  The algorithm does not check the return type of the function
/// from the function's definition to select an argument that matches the return type.
struct FunctionCallMutator {}

impl Mutator<SolidityAST> for FunctionCallMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        // We only want function call nodes with at least 1 argument.
        // We may want to ignore require() functions.
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "FunctionCall" {
                if let Some(arguments_node) = node.borrow_value_for_key("arguments") {
                    if let Some(arguments_array) = arguments_node.as_array() {
                        if arguments_array.len() > 0 {
                            return true;
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, rand: &mut Pcg64) {
        if let Some(arguments_node) = node.borrow_value_for_key("arguments") {
            if let Some(arguments_array) = arguments_node.as_array() {
                loop {
                    // Randomly pick an array member, but avoid Literal nodes.
                    let index = (rand.next_u64() % arguments_array.len() as u64) as usize;
                    let value = &arguments_array[index];
                    if let Some(node_type) = value.get_str_for_key("nodeType") {
                        if node_type == "Literal" {
                            continue;
                        }
                    }
                    *node = value.clone();
                    break;
                }
            }
        }
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::FunctionCall)
    }
}

/// Implements the function call argument swap mutation algorithm.
///
/// The mutator should identify function call expressions where the function call contains
/// at least two arguments of the same type.  The mutator will swap the two arguments.
struct SwapFunctionArgumentsMutator {}

impl SwapFunctionArgumentsMutator {
    /// Create the mutator object.
    pub fn new() -> SwapFunctionArgumentsMutator {
        SwapFunctionArgumentsMutator {}
    }
}

impl Mutator<SolidityAST> for SwapFunctionArgumentsMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "FunctionCall" {
                if let Some(arguments_node) = node.borrow_value_for_key("arguments") {
                    if let Some(arguments_array) = arguments_node.as_array() {
                        if arguments_array.len() > 1 {
                            // Now check to see if we have two nodes of the same type.  If we have
                            // two nodes of the same type then we can swap the arguments.
                            let mut type_map: HashMap<&str, i32> = HashMap::new();
                            for value in arguments_array {
                                if let Some(type_descriptions_node) =
                                    value.borrow_value_for_key("typeDescriptions")
                                {
                                    if let Some(type_string) =
                                        type_descriptions_node.get_str_for_key("typeString")
                                    {
                                        if type_map.contains_key(type_string) {
                                            let counter = type_map.get_mut(type_string).unwrap();
                                            *counter += 1;
                                        } else {
                                            type_map.insert(type_string, 1);
                                        }
                                    }
                                }
                            }

                            for (_key, value) in type_map {
                                if value >= 2 {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, rand: &mut Pcg64) {
        // We have the FunctionCall node with arguments of the same type. Iterate and find
        // nodes of the same type so that we can swap them.
        if let Some(mut arguments_node) = node.take_value_for_key("arguments") {
            if let Some(arguments_array) = arguments_node.as_array_mut() {
                let mut arg_map: HashMap<&str, Vec<IndexedNode>> = HashMap::new();
                for (index, value) in arguments_array.iter().enumerate() {
                    if let Some(type_descriptions_node) =
                        value.borrow_value_for_key("typeDescriptions")
                    {
                        if let Some(type_string) =
                            type_descriptions_node.get_str_for_key("typeString")
                        {
                            if arg_map.contains_key(type_string) {
                                let list = arg_map.get_mut(type_string).unwrap();
                                list.push(IndexedNode::new(index, value.clone()));
                            } else {
                                arg_map.insert(
                                    type_string,
                                    vec![IndexedNode::new(index, value.clone())],
                                );
                            }
                        }
                    }
                }

                // Attempt to randomly select a pair of args from the arg_map.  We do this by
                // putting the keys in the map that have a list with two or more arguments into
                // a list and then randomly indexing into the list to select a key.
                let mut list_list: Vec<Vec<IndexedNode>> = vec![];
                for (_key, value) in arg_map {
                    if value.len() >= 2 {
                        list_list.push(value);
                    }
                }

                let list_index = (rand.next_u64() % list_list.len() as u64) as usize;
                let node_list = &list_list[list_index];
                let in1 = &node_list[0];
                let in2 = &node_list[1];
                arguments_array.remove(in1.index);
                arguments_array.insert(in1.index, in2.node.clone());
                arguments_array.remove(in2.index);
                arguments_array.insert(in2.index, in1.node.clone());
                node.set_node_for_key("arguments", arguments_node);
            }
        }
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::FunctionSwapArguments)
    }
}

/// Implement the IfStatement mutation algorithm.
///
/// The algorithm will randomly choose between three possible mutations:
/// * The algorithm replaces the condition of the if statement with `true`.
/// * The algorithm replaces the condition of the if statement with `false`.
/// * The algorithm replaces the condition (called c) of the if statement with `!(c)`.
struct IfStatementMutator {}

impl Mutator<SolidityAST> for IfStatementMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "IfStatement" {
                if let Some(condition_node) = node.borrow_value_for_key("condition") {
                    if !condition_node.is_null() {
                        return true;
                    }
                }
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, rand: &mut Pcg64) {
        // Randomly choose between three possible mutations:
        // * Replace condition with true.
        // * Replace condition with false.
        // * Replace condition (called c) with !(c) (ie the negation).
        match rand.next_u64() % 3 as u64 {
            0 => {
                // Replace the condition with `true`.
                let bool_node = match new_boolean_literal_node(true) {
                    Ok(n) => n,
                    Err(_e) => return,
                };
                node.set_node_for_key("condition", bool_node);
            }
            1 => {
                // Replace the condition with `false`.
                let bool_node = match new_boolean_literal_node(false) {
                    Ok(n) => n,
                    Err(_e) => return,
                };
                node.set_node_for_key("condition", bool_node);
            }
            2 => {
                // Replace the condition (called c) with !(c).
                if let Some(condition_node) = node.take_value_for_key("condition") {
                    // Put the existing condition into an array.
                    let components_array: Vec<SolidityAST> = vec![condition_node];

                    // Put the array into a TupleExpression node.
                    let tuple_node = match new_tuple_expression_node(components_array) {
                        Ok(n) => n,
                        Err(_e) => return,
                    };

                    // Wrap the TupleExpression node in a UnaryOp (! TupleExpression).
                    let not_node = match new_unary_op_node("!", true, tuple_node) {
                        Ok(n) => n,
                        Err(_e) => return,
                    };

                    node.set_node_for_key("condition", not_node);
                }
            }
            _ => return,
        }
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::IfStatement)
    }
}

/// Implement the Integer mutation algorithm:
///
/// Randomly selects one from the following:
/// * Adds one to integer constant.
/// * Subtracts one from integer constant.
/// * Generates a random value.
struct IntegerMutator {}

impl Mutator<SolidityAST> for IntegerMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        // We look for a Literal node with an integer literal, not a floating point number.
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "Literal" {
                if let Some(kind) = node.get_str_for_key("kind") {
                    if kind == "number" {
                        if let Some(value) = node.get_str_for_key("value") {
                            let text = String::from(value);
                            // Search for a . in the string which indicates a floating point number.
                            let find_result = text.find(".");
                            if find_result == None {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, rand: &mut Pcg64) {
        match rand.next_u64() % 3 as u64 {
            0 => {
                // Add one to the integer constant.
                if let Some(value) = node.get_str_for_key("value") {
                    let value_string = value.to_string();
                    let mut my_integer = value_string.parse::<i64>().unwrap();
                    my_integer += 1;
                    node.set_str_for_key("value", my_integer.to_string().as_str());
                }
            }
            1 => {
                // Subtract one from the integer constant.
                if let Some(value) = node.get_str_for_key("value") {
                    let value_string = value.to_string();
                    let mut my_integer = value_string.parse::<i64>().unwrap();
                    my_integer -= 1;
                    node.set_str_for_key("value", my_integer.to_string().as_str());
                }
            }
            2 => {
                // Generate a random number.
                let value = rand.next_u64();
                node.set_str_for_key("value", value.to_string().as_str());
            }
            _ => return,
        }
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::Integer)
    }
}

/// Implement the operator swap mutation algorithm
///
/// The algorithm swaps the left and right hand sides of the arguments
/// to a BinaryOperation.  The operator of the BinaryOperation must
/// be in the list of non-commutative operators: [-, /, %, **, >, <, <=, >=, <<, >>]
struct OperatorSwapArgumentsMutator {
    valid_operators: Vec<&'static str>,
}

impl OperatorSwapArgumentsMutator {
    /// Create a new mutator.
    fn new() -> OperatorSwapArgumentsMutator {
        OperatorSwapArgumentsMutator {
            valid_operators: non_commutative_operators(),
        }
    }
}

impl Mutator<SolidityAST> for OperatorSwapArgumentsMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "BinaryOperation" {
                if let Some(operator_string) = node.get_str_for_key("operator") {
                    if self.valid_operators.contains(&operator_string) {
                        return true;
                    }
                }
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, _rand: &mut Pcg64) {
        if let Some(left_expr) = node.take_value_for_key("leftExpression") {
            if let Some(right_expr) = node.take_value_for_key("rightExpression") {
                node.set_node_for_key("leftExpression", right_expr);
                node.set_node_for_key("rightExpression", left_expr);
            }
        }
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::OperatorSwapArguments)
    }
}

/// Implement line swap mutation algorithm.
///
/// The algorithm chooses two lines from a block of code and attempts to randomly swap two of
/// the lines.  Since function return statements affect how a program compiles, the algorithm
/// will explicitly not swap lines with return statements.
struct LinesSwapMutator {}

impl Mutator<SolidityAST> for LinesSwapMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        // We need a function definition with at least two body statements.
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "Block" {
                if let Some(statements_node) = node.borrow_value_for_key("statements") {
                    if let Some(statements_array) = statements_node.as_array() {
                        if statements_array.len() >= 2 {
                            let mut found_return_statement = false;
                            for value in statements_array {
                                if let Some(value_node_type) = value.get_str_for_key("nodeType") {
                                    if value_node_type == "Return" {
                                        found_return_statement = true;
                                        break;
                                    }
                                }
                            }

                            // If the body of the function def has a return statement, then there
                            // must be at least 3 statements in the body in order to swap (but not
                            // swap a return statement) statements.  If there are no return statements
                            // then we can just go ahead and swap.
                            if (found_return_statement && statements_array.len() >= 3)
                                || (!found_return_statement)
                            {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, rand: &mut Pcg64) {
        if let Some(mut statements_node) = node.take_value_for_key("statements") {
            if let Some(statements_array) = statements_node.as_array_mut() {
                // Randomly pick a first node.
                let mut first_index: usize;
                loop {
                    first_index = (rand.next_u64() % statements_array.len() as u64) as usize;
                    if let Some(node_type) =
                        statements_array[first_index].get_str_for_key("nodeType")
                    {
                        if node_type == "Return" {
                            continue;
                        }
                    }
                    break;
                }

                // Try to randomly pick a second node.
                let mut second_index: usize;
                loop {
                    second_index = (rand.next_u64() % statements_array.len() as u64) as usize;
                    if second_index == first_index {
                        continue;
                    }
                    if let Some(node_type) =
                        statements_array[second_index].get_str_for_key("nodeType")
                    {
                        if node_type == "Return" {
                            continue;
                        }
                    }
                    break;
                }

                let larger_index = if first_index >= second_index {
                    first_index
                } else {
                    second_index
                };

                let smaller_index = if first_index >= second_index {
                    second_index
                } else {
                    first_index
                };

                let larger_node = statements_array.remove(larger_index);
                let smaller_node = statements_array.remove(smaller_index);
                statements_array.insert(smaller_index, larger_node);
                statements_array.insert(larger_index, smaller_node);
                node.set_node_for_key("statements", statements_node);
            }
        }
    }

    fn implements(&self) -> MutationType {
        MutationType::Generic(GenericMutation::LinesSwap)
    }
}

/// Implements the Solidity require function mutation algorithm.
///
/// This mutator will replace the expression in the argument to the Solidity `require` function
/// with the logical negation of the expression.
///
/// # Example
///
/// ```solidity
/// require(a > b);
/// ```
///
/// would become
///
/// ```solidity
/// require(!(a > b))
/// ```
struct SolidityRequireMutator {}

impl SolidityRequireMutator {
    /// Create the new require mutator.
    pub fn new() -> SolidityRequireMutator {
        SolidityRequireMutator {}
    }
}

impl Mutator<SolidityAST> for SolidityRequireMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        // Check that the node is a 'FunctionCall' node, that the function call is the
        // `require` function, and that the function has an argument.
        return node.get_str_for_key("nodeType").map_or_else(
            || false,
            |n| {
                n == "FunctionCall"
                    && (node.borrow_value_for_key("expression").map_or_else(
                        || false,
                        |n| {
                            n.get_str_for_key("name")
                                .map_or_else(|| false, |name| name == "require")
                        },
                    ))
                    && !node
                        .get_array_for_key("arguments")
                        .map_or_else(|| false, |v| v.is_empty())
            },
        );
    }

    fn mutate(&self, node: &mut SolidityAST, _: &mut Pcg64) {
        // First create a Unary ! operation node.
        let new_node_str = "{\
            \"id\": 99999,
            \"isConstant\": false,
            \"isLValue\": false,
            \"isPure\": true,
            \"lValueRequested\": false,
            \"nodeType\": \"UnaryOperation\",
            \"operator\": \"!\",
            \"prefix\": true,
            \"typeDescriptions\": {
                \"typeIdentifier\": \"t_bool\",
                \"typeString\": \"bool\"
            }
        }";
        let mut new_node = match new_json_node(new_node_str) {
            Ok(v) => v,
            Err(_) => return,
        };

        // Create a Tuple node to hold the function argument
        let tuple_expression_str = "{\
             \"id\": 99996,
             \"isConstant\": false,
             \"isInlineArray\": false,
             \"isLValue\": false,
             \"isPure\": false,
             \"lValueRequested\": false,
             \"nodeType\": \"TupleExpression\",
             \"typeDescriptions\": {
                 \"typeIdentifier\": \"t_bool\",
                 \"typeString\": \"bool\"
             }
        }";

        let mut tuple_expression_node = match new_json_node(tuple_expression_str) {
            Ok(v) => v,
            Err(_) => return,
        };

        let components_str = "[]";
        let mut components_node = match new_json_node(components_str) {
            Ok(v) => v,
            Err(_) => return,
        };

        // Get the node from the arguments list.
        let arg = match node.take_argument(0) {
            Some(n) => n,
            _ => {
                log::info!("Arguments list does not contain valid node");
                return;
            }
        };

        let components_array = match components_node.as_array_mut() {
            Some(v) => v,
            _ => return,
        };

        components_array.push(arg);
        tuple_expression_node["components"] = components_node;

        // Put the node into the generated UnaryOp node.
        new_node["subExpression"] = tuple_expression_node;
        node.set_node_for_key_at_index("arguments", 0, new_node);
    }

    fn implements(&self) -> MutationType {
        MutationType::Solidity(SolidityMutation::Require)
    }
}

/// Implements the unchecked block mutation algorithm for Solidity programs.
///
/// The algorithm selects a random expression statement from a Block and replaces
/// the statement with unchecked{ statement; }.  The algorithm will not select a
/// statement that contains a Return.
struct SolidityUncheckedBlockMutator {}

impl Mutator<SolidityAST> for SolidityUncheckedBlockMutator {
    fn is_mutable_node(&self, node: &SolidityAST) -> bool {
        if let Some(node_type) = node.get_str_for_key("nodeType") {
            if node_type == "Block" {
                if let Some(statements_node) = node.borrow_value_for_key("statements") {
                    if let Some(statements_array) = statements_node.as_array() {
                        if statements_array.len() > 0 {
                            let mut have_return_statement = false;
                            for value in statements_array {
                                if let Some(value_node_type) = value.get_str_for_key("nodeType") {
                                    if value_node_type == "Return" {
                                        have_return_statement = true;
                                        break;
                                    }
                                }
                            }

                            // If the Block node has a return statement, we need at least two statements
                            // in order for the algorithm to work.  We do not wrap a return statement
                            // in unchecked{}.
                            if (have_return_statement && statements_array.len() >= 2)
                                || (!have_return_statement)
                            {
                                return true;
                            }
                        }
                    }
                }
            }
        }
        false
    }

    fn mutate(&self, node: &mut SolidityAST, rand: &mut Pcg64) {
        if let Some(mut statements_node) = node.take_value_for_key("statements") {
            if let Some(statements_array) = statements_node.as_array_mut() {
                // Pick a random statement, but avoid Return statements.
                let mut node_to_wrap: SolidityAST;
                let mut index: usize;
                loop {
                    index = (rand.next_u64() % statements_array.len() as u64) as usize;
                    node_to_wrap = statements_array.remove(index);
                    if let Some(node_type) = node_to_wrap.get_str_for_key("nodeType") {
                        if node_type == "Return" {
                            continue;
                        }
                    }
                    break;
                }
                let wrapped_array = vec![node_to_wrap];
                let wrapped_node = match new_unchecked_block_node(wrapped_array) {
                    Ok(n) => n,
                    Err(_e) => return,
                };
                statements_array.insert(index, wrapped_node);
                node.set_node_for_key("statements", statements_node);
            }
        }
    }

    fn implements(&self) -> MutationType {
        MutationType::Solidity(SolidityMutation::UncheckedBlock)
    }
}

/// Implement the [`MutatorFactory<T>`] trait to have an interface for getting mutators for requested
/// mutation algorithms.
pub struct SolidityMutatorFactory {}

impl MutatorFactory<SolidityAST> for SolidityMutatorFactory {
    fn mutator_for(&self, mutation_type: &MutationType) -> Option<Box<dyn Mutator<SolidityAST>>> {
        match mutation_type {
            MutationType::Generic(t) => match t {
                GenericMutation::ArithmeticBinaryOp => Some(Box::new(BinaryOpMutator::new(
                    arithmetic_operators(),
                    MutationType::Generic(GenericMutation::ArithmeticBinaryOp),
                ))),
                GenericMutation::LogicalBinaryOp => Some(Box::new(BinaryOpMutator::new(
                    logical_operators(),
                    MutationType::Generic(GenericMutation::LogicalBinaryOp),
                ))),
                GenericMutation::BitwiseBinaryOp => Some(Box::new(BinaryOpMutator::new(
                    bitwise_operators(),
                    MutationType::Generic(GenericMutation::BitwiseBinaryOp),
                ))),
                GenericMutation::BitshiftBinaryOp => Some(Box::new(BinaryOpMutator::new(
                    bitshift_operators(),
                    MutationType::Generic(GenericMutation::BitshiftBinaryOp),
                ))),
                GenericMutation::ComparisonBinaryOp => Some(Box::new(BinaryOpMutator::new(
                    comparison_operators(),
                    MutationType::Generic(GenericMutation::ComparisonBinaryOp),
                ))),
                GenericMutation::Assignment => Some(Box::new(AssignmentMutator::new())),
                GenericMutation::DeleteStatement => Some(Box::new(DeleteStatementMutator {})),
                GenericMutation::FunctionCall => Some(Box::new(FunctionCallMutator {})),
                GenericMutation::FunctionSwapArguments => {
                    Some(Box::new(SwapFunctionArgumentsMutator::new()))
                }
                GenericMutation::IfStatement => Some(Box::new(IfStatementMutator {})),
                GenericMutation::Integer => Some(Box::new(IntegerMutator {})),
                GenericMutation::OperatorSwapArguments => {
                    Some(Box::new(OperatorSwapArgumentsMutator::new()))
                }
                GenericMutation::LinesSwap => Some(Box::new(LinesSwapMutator {})),
                GenericMutation::UnaryOp => Some(Box::new(UnaryOpMutator::new())),
            },
            MutationType::Solidity(t) => match t {
                SolidityMutation::Require => Some(Box::new(SolidityRequireMutator::new())),
                SolidityMutation::UncheckedBlock => {
                    Some(Box::new(SolidityUncheckedBlockMutator {}))
                }
            },
        }
    }
}
